<h1>CodeChat Editor ideas</h1>
<div>The CodeChat Editor should be a GUI-based programmer's word processor /
    Jupyter for software developers.</div>
<h2>Next steps</h2>
<ol>
    <li>Set up a good development environment for JavaScript: use npm,
        TypeScript, a good unit-testing library, etc.</li>
    <li>Sketch out a long-term path for book builds. Goal: very rapid builds.
    </li>
    <li>Define the architecture for IDE extensions/plug-ins. Goal: minimize
        extension/plug-in complexity.</li>
    <li>Define desired UI behavior. Priority: auto-reload; dirty document
        detection; auto-backup.</li>
    <li>Implement Markdown support.</li>
    <li>Propose visual styling, dark mode, etc.</li>
</ol>
<h2>Specifications / ideas</h2>
<div>At a very high level, what should this do? How?</div>
<div>
    <ul>
        <li>View source code as code blocks and doc blocks. Doc blocks are lines
            of source which contain only comments.</li>
        <li>Load a document from source code, allow edits in a GUI, then save it
            back to source code.
            <ul>
                <li>Provide word processor GUI tools (insert hyperlink, images,
                    headings, change font, etc) for doc blocks.</li>
                <li>Provide text editor/IDE tools (syntax highlighting, line
                    numbers, show linter feedback) for code blocks.</li>
            </ul>
        </li>
        <li>Ideally, be a zero-install environment. Practically, I don't think
            this is possible without a server. If so, make the server as easy to
            install as possible. I suspect that updates to an IDE's plugin will
            happen frequently, while users won't update the server very often,
            so push as much code into the JavaScript as possible. The current
            zero-install code would make a nice web demo -- paste in / drag and
            drop / open your code, click on the other tab to edit it in the GUI.
        </li>
        <li>Doc block markup should be readable and well-known.
            <ul>
                <li>For any markup, must either have:
                    <ul>
                        <li>Round-trip capable conversion: from x to HTML
                            (load), then from HTML back to x (save).</li>
                        <li>A GUI editor that works on this markup language. I
                            don't know of any (except for HTML).</li>
                    </ul>
                </li>
                <li>HTML is simple to implement (already done). However, it's
                    less readable.</li>
                <li>Markdown is very well known, dut to GitHub's use of it, and
                    is more readable (IMHO). It seems like a possible candidate
                    -- anything that can't be translated from HTML from Markdown
                    can simply be left as HTML, since Markdown allows HTML as a
                    part of its syntax. Markdown has a JavaScript implementation
                    for markdown to HTML. Pandoc can translate HTML back to
                    Markdown, but this requires installation of another program
                    and adds to the server-side complexity. The <a
                        href="https://github.com/commonmark/commonmark.js/blob/master/lib/render/html.js">code</a>
                    that CommonMark uses to translate from their AST into HTML
                    looks pretty straightforward, so the inverse shouldn't be
                    too hard.</li>
            </ul>
        </li>
        <li>To support creating a web site / book / project, the server needs to
            serve one (simpler) flavor of web page for a single-file build, and
            another for a project build. However, the rendering of code and doc
            blocks is still dynamic, not static. Basically, a project build
            would include a template with a table of contents, prev/next
            buttons, search, etc. Need to architect this; what does it mean to
            do a project build? What about supporting ReadTheDocs / a
            server-free build?
            <ul>
                <li>One approach: code most of this in V. Then, we can run the
                    code on the desktop for a static, zero-hydration build, or
                    in the browser where editing can happen.</li>
                <li>Need to segment code between editing/UI (web only) and
                    rendering (web/desktop).</li>
                <li>A project is a template, a TOC and associated numbering,
                    global crossrefs, and search terms (which could be
                    dynamically computed by the server).
                    <ul>
                        <li>Perhaps there's a single project config file as
                            YAML/XML/whatever that defines the TOC, book build
                            params, etc.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>I would ideally like to use a programming language that runs both on
            the desktop, with minimal dependencies, and in the browser.
            JavaScript + Node.js is one possibility (but the install process
            isn't nice). vlang seems pretty good as well -- everything compiles
            to an executable, and also builds to WebAssembly.</li>
    </ul>
    <h2>Core development priorities</h2>
    <ol>
        <li>IDE integration</li>
        <li>Editor functionality</li>
        <li>Project support</li>
    </ol>
    <h2>Project support</h2>
    <ul>
        <li>A project is a specific directory tree, identified by the presence
            of a project configuration file named
            <code>codechat_project.????</code>.</li>
        <li>A page in a project build is a single-file page plus:
            <ul>
                <li>A TOC, along with previous/next/up navigation.</li>
                <li>Numbering comes from the current page's location within the
                    TOC. Pages not in the TOC aren't numbered.</li>
                <li>The ability to search the project, ideally using an
                    i-search. A search over the text in all headings and index
                    terms, then over all text, would be good. This requires
                    keeping a dict of all words in all files; the words must be
                    separated into headings/link text and all other text. It
                    should exclude common programing terms (keywords such as if,
                    for, case, etc.) and discard non-word characters. This seems
                    reasonably doable. This should be updated whenever a file is
                    saved. For now, leave searches with the IDE.</li>
            </ul>
        </li>
        <li>Eliminate the traditional project build process -- make it almost
            instantaneous. Instead, on save, the system should update all
            affected files; any opened files should also be updated in the
            browser. For example, editing the TOC then saving should cause the
            new TOC to auto-update in all open files. Opening another file would
            also show the updated TOC. Likewise, changing
            <code>&lt;h1&gt;</code> heading text in a file referenced by the TOC
            then saving would cause the TOC to update globally.
            <ul>
                <li>This seems like a good server-side templating opportunity.
                    When the server loads a file which refers to text from
                    external files, it templates in the necessary text by
                    opening these linked files and reading the necessary text;
                    it also keeps track of what links are being edited, so it
                    can push live updates to these files.</li>
                <li>A tricker case: editing the id of a link target should
                    ideally update this id in the links of all referring files.
                    Likewise, renaming a file should update all links in
                    referring files. This requires a DAG and global state -- a
                    feature for later.&nbsp;As a bonus, the DAG can identify any
                    unconnected files or unused ids/bookmarks, then warn the
                    author about these "orphans." It can also identify any
                    broken links to project files. The DAG could be
                    incrementally updated on a save, with occasional scans of
                    the project's subdirectory tree to find any edits made
                    outside of the CodeChat Editor.</li>
            </ul>
        </li>
        <li>TOC
            <ul>
                <li>Example: I like&nbsp;<a
                        href="https://rust-lang.github.io/mdBook/format/summary.html">mdbook's
                        approach</a>, but don't want to parse Markdown.</li>
                <li>Browsing to any page of the project should automatically
                    scroll to portion of the TOC that links to the page.</li>
                <li>A given page needs to know the section number assigned to it
                    by the TOC.</li>
                <li>While the TOC file, must be placed in the root of the
                    project, it will be served alongside pages served from
                    subdirectories. What's the best approach? An iframe;
                    otherwise, need to rewrite all url (images, links, etc.)
                    which sounds hard.</li>
                <li>Implementation: have the TOC just be HTML. It should be
                    wrapped in a <a
                        href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav">&lt;nav&gt;
                        tag</a>. Require that numbered sections be expressed as
                    nested ordered lists, with links to each section inside
                    these lists.
                    <ul>
                        <li>Then,&nbsp;<code>document.querySelector('[href="https://example.com"]')</code>
                            finds the first instance of the current page's link,
                            which takes care of scrolling the TOC.</li>
                        <li>Given the a element in the TOC, looking through its
                            parents provides the section number. Given an array
                            of section numbers, use CSS to style all the
                            headings. One approach, which makes it easy for a
                            style sheet to include or exclude section numbers,
                            by making them CSS variables:<br>
                            <p><code>:root {</code><br><code>&nbsp;
                                    --section-counter-reset: s1 4 s2
                                    5;</code><br><code>&nbsp;
                                    --section-counter-content: counter(s1,
                                    numeric) '-' counter(s2,
                                    numeric);</code><br><code>}</code></p>
                            <p><code>h1::before {</code><br><code>&nbsp;
                                    counter-reset:
                                    var(--section-counter-reset);</code><br><code>&nbsp;
                                    content:
                                    var(--section-counter-content);</code><br><code>}</code>
                            </p>
                        </li>
                        <li>Side note: ideally, we'd ask the DOM for the
                            marker/number preceeding an ordered list item. JS
                            can find the index of each item in an ordered list,
                            but it won't get the actual marker used (Roman
                            numbers, bullets, or things generated by <a
                                href="https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type">list-style-type</a>).
                            There's a CSS&nbsp;<a
                                href="https://developer.mozilla.org/en-US/docs/Web/CSS/::marker">::marker</a>
                            selector, but not way to get the rendered text. Even
                            <a
                                href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText">innerText</a>
                            doesn't include the marker in the resulting text --
                            ack!</li>
                        <li>Plan:
                            <ol>
                                <li>Implement a view mode, since the TOC should
                                    be viewable, but not editable. (To edit the
                                    TOC, open it in the main window, not just
                                    the TOC sidebar.)</li>
                                <li>Implement a project finder -- starting at
                                    the current directory, ascend to the root
                                    looking for the project file. If so, return
                                    a web page which includes the TOC as a
                                    sidebar plus some navigation (prev/next/up)
                                    placeholders.</li>
                                <li>Implement TOC scroll (on the client -- easy
                                    there). This means finding the first
                                    hyperlink to the current page. Given that,
                                    it's fairly easy to determine prev/next/up
                                    and section numbers. Implement all these.
                                </li>
                            </ol>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>Implementation
            <ul>
                <li>The load/save code needs to run on the server if we do
                    server-side templating, or if we want the server to be able
                    to produce a static build. It needs to run on the client, so
                    that the client can detect comments in a code block or
                    switch between raw and editor/viewer modes. What other code
                    needs to be shared? For now, the idea of compiling V to
                    Javascript isn't very appealing, but I need to at least test
                    it out. Another option: the client calls a server endpoint
                    to update needed links, but still does all parsing on the
                    client. That seems fairly easy.</li>
            </ul>
        </li>
        <li>Open questions
            <ul>
                <li>How to enable affecting the <code>&lt;head&gt;</code> of a
                    page? Of the entire project?</li>
                <li>Config file format: I really like and prefer Python's
                    strictyaml. Basically, I want something that includes type
                    validation and allows comments withing the config file.
                    Perhaps JSON with a pre-parse step to discard comments
                    then&nbsp;<a href="https://jsontypedef.com/">JSON
                        Typedef</a>? Possibly, vlang can do this somewhat, since
                    it wants to decode JSON into a V struct.)</li>
                <li>Config file contents: need to think through what belongs
                    here. How to keep it as simple as possible? Perhaps provide
                    a web-based GUI to make this easier to configure?</li>
                <li>How to specify the language for a doc block? Currently, we
                    only support HTML. However, I'd like to support Markdown,
                    and possibly also reST. Ideas: extensions, plus a default
                    setting in a project file or the GUI; include a comment in
                    the file.</li>
            </ul>
        </li>
    </ul>
</div>
<h2>How to run</h2>
<div>The CodeChat repository's <a
        href="https://github.com/bjones1/CodeChat/tree/CodeChat-Editor/CodeChat">CodeChat-Editor
        branch</a> contains the code for this idea. To try it out:</div>
<div>
    <ol>
        <li><a
                href="https://github.com/vlang/v#installing-v---from-source-preferred-method">Install
                the V language</a>. On non-Windows systems, <a
                href="https://github.com/vlang/v#v-nethttp-netwebsocket-v-install">install
                OpenSSL libraries</a>.</li>
        <li><a href="https://github.com/vlang/v#symlinking">Symlink V</a>.</li>
        <li>In this directory, execute <code>v crun
                CodeChatEditorServer.v</code>.</li>
        <li>Open http://localhost:8080 in your browser.</li>
    </ol>
</div>