<h1>CodeChat Editor ideas</h1>
<div>The CodeChat Editor should be a GUI-based programmer's word processor /
    Jupyter for software developers.</div>
<h2>Next steps</h2>
<ol>
    <li>Set up a good development environment for JavaScript: use npm,
        TypeScript, a good unit-testing library, etc.</li>
    <li>Sketch out a long-term path for book builds. Goal: very rapid builds.
    </li>
    <li>Define the architecture for IDE extensions/plug-ins. Goal: minimize
        extension/plug-in complexity.</li>
    <li>Define desired UI behavior. Priority: auto-reload; dirty document
        detection; auto-backup.</li>
    <li>Implement Markdown support.</li>
    <li>Propose visual styling, dark mode, etc.</li>
</ol>
<h2>Specifications / ideas</h2>
<div>At a very high level, what should this do? How?</div>
<div>
    <ul>
        <li>View source code as code blocks and doc blocks. Doc blocks are lines
            of source which contain only comments.</li>
        <li>Load a document from source code, allow edits in a GUI, then save it
            back to source code.
            <ul>
                <li>Provide word processor GUI tools (insert hyperlink, images,
                    headings, change font, etc) for doc blocks.</li>
                <li>Provide text editor/IDE tools (syntax highlighting, line
                    numbers, show linter feedback) for code blocks.</li>
            </ul>
        </li>
        <li>Ideally, be a zero-install environment. Practically, I don't think
            this is possible without a server. If so, make the server as easy to
            install as possible. I suspect that updates to an IDE's plugin will
            happen frequently, while users won't update the server very often,
            so push as much code into the JavaScript as possible. The current
            zero-install code would make a nice web demo -- paste in / drag and
            drop / open your code, click on the other tab to edit it in the GUI.
        </li>
        <li>Doc block markup should be readable and well-known.
            <ul>
                <li>For any markup, must either have:
                    <ul>
                        <li>Round-trip capable conversion: from x to HTML
                            (load), then from HTML back to x (save).</li>
                        <li>A GUI editor that works on this markup language. I
                            don't know of any (except for HTML).</li>
                    </ul>
                </li>
                <li>HTML is simple to implement (already done). However, it's
                    less readable.</li>
                <li>Markdown is very well known, dut to GitHub's use of it, and
                    is more readable (IMHO). It seems like a possible candidate
                    -- anything that can't be translated from HTML from Markdown
                    can simply be left as HTML, since Markdown allows HTML as a
                    part of its syntax. Markdown has a JavaScript implementation
                    for markdown to HTML. Pandoc can translate HTML back to
                    Markdown, but this requires installation of another program
                    and adds to the server-side complexity. The <a
                        href="https://github.com/commonmark/commonmark.js/blob/master/lib/render/html.js">code</a>
                    that CommonMark uses to translate from their AST into HTML
                    looks pretty straightforward, so the inverse shouldn't be
                    too hard.</li>
            </ul>
        </li>
        <li>To support creating a web site / book / project, the server needs to
            serve one (simpler) flavor of web page for a single-file build, and
            another for a project build. However, the rendering of code and doc
            blocks is still dynamic, not static. Basically, a project build
            would include a template with a table of contents, prev/next
            buttons, search, etc. Need to architect this; what does it mean to
            do a project build? What about supporting ReadTheDocs / a
            server-free build?
            <ul>
                <li>One approach: code most of this in V. Then, we can run the
                    code on the desktop for a static, zero-hydration build, or
                    in the browser where editing can happen.</li>
                <li>Need to segment code between editing/UI (web only) and
                    rendering (web/desktop).</li>
                <li>A project is a template, a TOC and associated numbering,
                    global crossrefs, and search terms (which could be
                    dynamically computed by the server).
                    <ul>
                        <li>Perhaps there's a single project config file as
                            YAML/XML/whatever that defines the TOC, book build
                            params, etc.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>I would ideally like to use a programming language that runs both on
            the desktop, with minimal dependencies, and in the browser.
            JavaScript + Node.js is one possibility (but the install process
            isn't nice). vlang seems pretty good as well -- everything compiles
            to an executable, and also builds to WebAssembly.</li>
    </ul>
    <h2>Core development priorities</h2>
    <ol>
        <li>IDE integration</li>
        <li>Editor functionality</li>
        <li>Project support</li>
    </ol>
    <h2>Project support</h2>
    <ul>
        <li>A project is a specific directory tree, probably identified by the
            presence of a project configuration file.</li>
        <li>The project configuration file contains the author-specified table
            of contents (TOC).</li>
        <li>A page in a project build is a single-file page plus:
            <ul>
                <li>A TOC, along with previous/next/up navigation.</li>
                <li>Numbering comes from the current page's location within the
                    TOC. Pages not in the TOC aren't numbered.</li>
                <li>The ability to search the project, ideally using an
                    i-search. A search over the text in all headings and index
                    terms, then over all text, would be good.</li>
            </ul>
        </li>
        <li>The project build system computes a DAG of all hyperlinks:
            <ul>
                <li>It can identify any unconnected files, then warn the author
                    about these "orphans."</li>
                <li>Changing the text of a heading causes quick updates to all
                    references to these hyperlinks based on the nearest neighbor
                    in the DAG. Similar support for renaming/moving files,
                    deleting a referenced item, finding broken hyperlinks to
                    nonexistent locations, etc.</li>
                <li>Index terms are a flavor of hyperlink: from the index page
                    to the page(s) which use that term. Perhaps also provide an
                    in-place crossref: interacting with an index term on a page
                    would produce a hyperlinked list of other pages which
                    contain that same term.</li>
            </ul>
        </li>
    </ul>
</div>
<h2>How to run</h2>
<div>The CodeChat repository's <a
        href="https://github.com/bjones1/CodeChat/tree/CodeChat-Editor/CodeChat">CodeChat-Editor
        branch</a> contains the code for this idea. To try it out:</div>
<div>
    <ol>
        <li><a
                href="https://github.com/vlang/v#installing-v---from-source-preferred-method">Install
                the V language</a>. On non-Windows systems, <a
                href="https://github.com/vlang/v#v-nethttp-netwebsocket-v-install">install
                OpenSSL libraries</a>.</li>
        <li><a href="https://github.com/vlang/v#symlinking">Symlink V</a>.</li>
        <li>In this directory, execute <code>v crun
                CodeChatEditorServer.v</code>.</li>
        <li>Open http://localhost:8080 in your browser.</li>
    </ol>
</div>